<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="viewport" content="width=device-width, initial-scale=1.0">
    <title>I Wanna Lockpick Solver - Collaborative Multi-Bot</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f4;
            color: #333;
            text-align: center;
            padding: 20px;
        }
        #solver-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
        }
        .bot-container {
            border: 1px solid #ccc;
            border-radius: 8px;
            padding: 10px;
            width: 300px;
            background-color: #fafafa;
        }
        .output {
            background-color: #e9e9e9;
            border: 1px solid #ccc;
            border-radius: 5px;
            overflow-y: auto;
            max-height: 200px;
            text-align: left;
            padding: 5px;
            font-size: 0.9em;
        }
        .stats {
            font-size: 0.9em;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <h1>I Wanna Lockpick Solver - Collaborative Multi-Bot</h1>
    <p>Click "Start All Bots" to run four collaborative solvers, each with its own log and stats.</p>
    <button onclick="startAllBots()">Start All Bots</button>

    <div id="solver-container">
        <!-- Containers for each bot -->
        <div id="bot1" class="bot-container">
            <h2>Bot 1</h2>
            <div id="output1" class="output"></div>
            <div id="stats1" class="stats"></div>
        </div>
        <div id="bot2" class="bot-container">
            <h2>Bot 2</h2>
            <div id="output2" class="output"></div>
            <div id="stats2" class="stats"></div>
        </div>
        <div id="bot3" class="bot-container">
            <h2>Bot 3</h2>
            <div id="output3" class="output"></div>
            <div id="stats3" class="stats"></div>
        </div>
        <div id="bot4" class="bot-container">
            <h2>Bot 4</h2>
            <div id="output4" class="output"></div>
            <div id="stats4" class="stats"></div>
        </div>
    </div>

    <script>
        // Shared knowledge pool for cross-bot learning
        const knowledgePool = new Map();

        function logToOutput(botId, message) {
            const outputElement = document.getElementById(`output${botId}`);
            outputElement.innerHTML += message + '\n';
            outputElement.scrollTop = outputElement.scrollHeight; // Auto-scroll to the latest message
        }

        function updateStats(botId, steps, keys) {
            const statsElement = document.getElementById(`stats${botId}`);
            statsElement.innerHTML = `Steps: ${steps} | Keys - Cyan: ${keys.cyan}, Pink: ${keys.pink}, Green: ${keys.green}, White: ${keys.white}`;
        }

        const initialState = { keys: { white: 0, cyan: 0, pink: 0, green: 0 }, steps: 0, path: [] };

        function isGoalCondition(state) {
            const minKeys = 5;
            const balanced = Object.values(state.keys).every(count => count >= minKeys);
            const canDivide = state.keys.white > 0 && state.keys.pink % state.keys.white === 0 && state.keys.green % state.keys.white === 0;
            return balanced && canDivide;
        }

        function calculateReward(state) {
            const balanceScore = Object.values(state.keys).reduce((sum, count) => sum + Math.min(count, 5), 0);
            const divisionScore = (state.keys.white > 0 && state.keys.pink % state.keys.white === 0 && state.keys.green % state.keys.white === 0) ? 10 : 0;
            return balanceScore + divisionScore;
        }

        function collectKey(state, color) {
            const newState = JSON.parse(JSON.stringify(state));
            newState.keys[color]++;
            newState.steps++;
            newState.path.push(`Collected ${color} key`);
            return newState;
        }

        function divideKeys(state) {
            const newState = JSON.parse(JSON.stringify(state));
            if (newState.keys.white > 0 && newState.keys.pink % newState.keys.white === 0 && newState.keys.green % newState.keys.white === 0) {
                newState.keys.pink /= newState.keys.white;
                newState.keys.green /= newState.keys.white;
                newState.steps++;
                newState.path.push(`Divided pink and green keys by white`);
                return newState;
            }
            return null;
        }

        async function processQueue(botId, queue, visited, solutions) {
            const chunkSize = 20;
            const topKStates = 50;
            let iterations = 0;

            while (queue.length > 0) {
                if (iterations >= chunkSize) {
                    iterations = 0;
                    await new Promise(resolve => setTimeout(resolve, 0));
                }

                const currentState = queue.shift();
                const keys = JSON.stringify(currentState.keys);

                if (visited.has(keys)) continue;
                visited.add(keys);

                if (isGoalCondition(currentState)) {
                    logToOutput(botId, `Goal reached in ${currentState.steps} steps!`);
                    solutions.push(currentState);
                    updateStats(botId, currentState.steps, currentState.keys);
                    knowledgePool.set(keys, currentState); // Share this state with other bots
                    continue;
                }

                if (currentState.steps % 100 === 0) {
                    logToOutput(botId, `Step ${currentState.steps}: Cyan=${currentState.keys.cyan}, Pink=${currentState.keys.pink}, Green=${currentState.keys.green}, White=${currentState.keys.white}`);
                    updateStats(botId, currentState.steps, currentState.keys);
                }

                let newStates = [
                    collectKey(currentState, 'cyan'),
                    collectKey(currentState, 'pink'),
                    collectKey(currentState, 'green'),
                    collectKey(currentState, 'white')
                ];
                const dividedState = divideKeys(currentState);
                if (dividedState) newStates.push(dividedState);

                // Pull in knowledge from other bots
                if (Math.random() < 0.1) {  // Occasionally check the knowledge pool
                    for (const [_, sharedState] of knowledgePool) {
                        if (!visited.has(JSON.stringify(sharedState.keys))) {
                            newStates.push(sharedState);
                        }
                    }
                }

                newStates = newStates
                    .map(state => ({ state, reward: calculateReward(state) }))
                    .sort((a, b) => b.reward - a.reward)
                    .slice(0, topKStates)
                    .map(item => item.state);

                newStates.forEach(state => queue.push(state));
                iterations++;
            }
        }

        async function startBot(botId) {
            const queue = [JSON.parse(JSON.stringify(initialState))];
            const visited = new Set();
            const solutions = [];

            logToOutput(botId, "Bot started...");
            await processQueue(botId, queue, visited, solutions);

            if (solutions.length === 0) {
                logToOutput(botId, 'No solutions found.');
            } else {
                solutions.forEach((solution, index) => {
                    logToOutput(botId, `\nSolution ${index + 1} (Steps: ${solution.steps}): ${solution.path.join(' -> ')}`);
                });
            }
        }

        function startAllBots() {
            startBot(1);
            startBot(2);
            startBot(3);
            startBot(4);
        }
    </script>
</body>
</html>
