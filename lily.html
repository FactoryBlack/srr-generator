<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>I Wanna Lockpick Puzzle Solver</title>
    <style>
        .console-output {
            width: 100%;
            height: 300px;
            overflow-y: auto;
            background-color: #333;
            color: #eee;
            font-family: monospace;
            padding: 10px;
            border: 1px solid #222;
            white-space: pre-line;
        }

        #startButton, #loadButton {
            margin-bottom: 10px;
        }
    </style>
</head>
<body>

<h1>I Wanna Lockpick Puzzle Solver</h1>
<select id="levelSelect">
    <option value="new_level.json">New Level</option>
</select>
<button id="loadButton">Load Level</button>
<button id="startButton">Start Solver</button>
<div id="log" class="console-output"></div>

<script>
// Initialize variables
let puzzleData;
let solutionSteps = []; // Array to store the sequence of actions

// Function to log messages with auto-scroll
function logMessage(message) {
    const logDiv = document.getElementById("log");
    const messageElement = document.createElement("div");
    messageElement.textContent = message;
    logDiv.appendChild(messageElement);
    logDiv.scrollTop = logDiv.scrollHeight;
}

// Fetch the selected level data from JSON file
async function loadLevelData() {
    const levelFile = document.getElementById("levelSelect").value;
    try {
        const response = await fetch(levelFile);
        puzzleData = await response.json();
        logMessage(`Loaded ${levelFile}`);
    } catch (error) {
        logMessage(`Error loading level data: ${error}`);
    }
}

// Collect a specific key amount and log
function collectKey(data, color, amount) {
    if (!data.keys[color]) {
        logMessage(`Error: Key color '${color}' is not defined in data.keys.`);
        return;
    }
    data.keys[color].real += amount.real;
    data.keys[color].imag += amount.imag;
    logMessage(`Collected ${amount.real !== 0 ? amount.real : ''}${amount.imag !== 0 ? ' + ' + amount.imag + 'i' : ''} ${color} key(s). Total: ${data.keys[color].real} + ${data.keys[color].imag}i`);

    // Record action
    solutionSteps.push(`Collect ${amount.real !== 0 ? amount.real : ''}${amount.imag !== 0 ? ' + ' + amount.imag + 'i' : ''} ${color} key(s)`);
}

// Check for aura activation based on key counts
function checkAuras(data) {
    let auras = { redAura: false, greenAura: false, blueAura: false, negativeBrownAura: false };

    if (data.keys.red.real >= 1) {
        logMessage("Red aura activated! Frozen doors can be defrosted.");
        auras.redAura = true;
        solutionSteps.push("Activate red aura");
    }
    if (data.keys.green.real >= 5) {
        logMessage("Green aura activated! Eroded doors can be healed.");
        auras.greenAura = true;
        solutionSteps.push("Activate green aura");
    }
    if (data.keys.blue.real >= 3) {
        logMessage("Blue aura activated! Painted doors can be cleaned.");
        auras.blueAura = true;
        solutionSteps.push("Activate blue aura");
    }
    if (data.keys.brown.real < 0) {
        logMessage("Negative brown aura activated! Curses can now be removed from nearby doors.");
        auras.negativeBrownAura = true;
        solutionSteps.push("Activate negative brown aura");
    }
    return auras;
}

// Open a door if it's in the required path to reach the goal
function openDoor(data, door, auras) {
    if (!data.goal.required_doors.includes(door.color)) {
        logMessage(`Skipping ${door.color} door as it is not required for reaching the goal.`);
        return false;
    }

    if (door.type === 'frozen' && door.corrupted) {
        if (auras.redAura) {
            logMessage(`Defrosted frozen ${door.color} door with red aura.`);
            door.corrupted = false;
            solutionSteps.push(`Defrost ${door.color} door with red aura`);
        } else {
            logMessage(`Cannot defrost frozen ${door.color} door. Red aura not active.`);
            return false;
        }
    }

    if (door.type === 'eroded' && door.corrupted) {
        if (auras.greenAura) {
            logMessage(`Healed eroded ${door.color} door with green aura.`);
            door.corrupted = false;
            solutionSteps.push(`Heal ${door.color} door with green aura`);
        } else {
            logMessage(`Cannot heal eroded ${door.color} door. Green aura not active.`);
            return false;
        }
    }

    if (door.type === 'painted' && door.corrupted) {
        if (auras.blueAura) {
            logMessage(`Cleaned painted ${door.color} door with blue aura.`);
            door.corrupted = false;
            solutionSteps.push(`Clean ${door.color} door with blue aura`);
        } else {
            logMessage(`Cannot clean painted ${door.color} door. Blue aura not active.`);
            return false;
        }
    }

    if (door.type === 'cursed') {
        if (auras.negativeBrownAura) {
            logMessage(`Opened cursed ${door.color} door using negative brown aura.`);
            door.copies -= 1;
            solutionSteps.push(`Open cursed ${door.color} door with negative brown aura`);
            return true;
        } else {
            logMessage(`Cannot open cursed ${door.color} door without negative brown aura.`);
            return false;
        }
    }

    for (const lock of door.locks) {
        const { color, cost } = lock;
        if (!data.keys[color]) {
            logMessage(`Error: Attempted to use undefined key color '${color}' for ${door.color} door.`);
            return false;
        }
        data.keys[color].real -= cost.real;
        data.keys[color].imag -= cost.imag;
        logMessage(`Used ${cost.real !== 0 ? cost.real : ''}${cost.imag !== 0 ? ' + ' + cost.imag + 'i' : ''} ${color} key(s) to open part of ${door.color} door.`);
        solutionSteps.push(`Use ${cost.real !== 0 ? cost.real : ''}${cost.imag !== 0 ? ' + ' + cost.imag + 'i' : ''} ${color} key(s) to open ${door.color} door`);
    }

    door.copies -= 1;
    logMessage(`Opened ${door.color} door. Remaining copies: ${door.copies}`);
    return true;
}

// Check if all necessary doors in required_doors are open to reach the goal
function checkGoal(data) {
    if (!data.goal || !Array.isArray(data.goal.required_doors)) {
        logMessage("Error: required_doors is not defined in goal or is not an array.");
        return;
    }

    const pathClear = data.goal.required_doors.every(color => {
        const door = data.doors.find(d => d.color === color);
        return door && (door.copies <= 0 || !door.corrupted);
    });

    if (pathClear) {
        data.goal.reached = true;
        logMessage("Goal reached! Green check mark accessed.");
        logMessage("Steps to reach the goal:");
        solutionSteps.forEach(step => logMessage(step));
    } else {
        logMessage("Goal not yet reached. Check required doors or logic.");
    }
}

// Test function to solve the puzzle
async function cursedDoorTest() {
    logMessage("Starting solver...");

    const testData = JSON.parse(JSON.stringify(puzzleData));
    solutionSteps = []; // Reset solution steps

    for (const key of testData.keysToCollect) {
        collectKey(testData, key.color, key.amount);
    }

    const auras = checkAuras(testData);

    testData.doors.forEach(door => openDoor(testData, door, auras));
    checkGoal(testData);
}

// Event listeners for Load and Start buttons
document.getElementById("loadButton").addEventListener("click", loadLevelData);
document.getElementById("startButton").addEventListener("click", cursedDoorTest);

</script>
</body>
</html>
