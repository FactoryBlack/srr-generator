<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>I Wanna Lockpick Solver</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f4;
            color: #333;
            text-align: center;
            padding: 20px;
        }
        #solver-container {
            max-width: 800px;
            margin: 0 auto;
        }
        #output {
            margin-top: 20px;
            padding: 10px;
            background-color: #e9e9e9;
            border: 1px solid #ccc;
            border-radius: 5px;
            overflow-y: scroll;
            max-height: 300px;
            text-align: left;
        }
    </style>
</head>
<body>
    <div id="solver-container">
        <h1>I Wanna Lockpick Solver</h1>
        <p>Click the button below to start the adaptive solver for "I Wanna Lockpick".</p>
        <button onclick="startSolver()">Start Solver</button>

        <div id="output">
            <h2>Solver Output</h2>
            <pre id="result"></pre>
        </div>
    </div>

    <script>
        function logToOutput(message) {
            const resultElement = document.getElementById('result');
            resultElement.innerHTML += message + '\n';
            resultElement.scrollTop = resultElement.scrollHeight;
        }

        const initialState = {
            keys: { white: 0, cyan: 0, pink: 0, green: 0 },
            steps: 0,
            path: []
        };

        // Determine if a state has reached a desired balance or condition
        function isGoalCondition(state) {
            // Example dynamic goal condition:
            // Aim for at least a minimal number of keys for each color, or where a useful division is possible
            const threshold = 5;
            const balanced = Object.values(state.keys).every(count => count >= threshold);
            const canDivide = state.keys.white > 0 && state.keys.pink % state.keys.white === 0 && state.keys.green % state.keys.white === 0;
            return balanced || canDivide;
        }

        // Reward-based heuristic to evaluate the usefulness of a state
        function calculateReward(state) {
            const balanceScore = Object.values(state.keys).reduce((sum, count) => sum + Math.min(count, 5), 0);
            const divisionScore = (state.keys.white > 0 && state.keys.pink % state.keys.white === 0 && state.keys.green % state.keys.white === 0) ? 10 : 0;
            return balanceScore + divisionScore;
        }

        function collectKey(state, color) {
            const newState = JSON.parse(JSON.stringify(state));
            newState.keys[color]++;
            newState.steps += 1;
            newState.path.push(`Collected ${color} key (Total ${color} keys: ${newState.keys[color]})`);
            logToOutput(`Action ${newState.steps}: Collected ${color} key. New count of ${color} keys: ${newState.keys[color]}`);
            return newState;
        }

        function divideKeys(state) {
            const newState = JSON.parse(JSON.stringify(state));
            if (newState.keys.white > 0 && newState.keys.pink % newState.keys.white === 0 && newState.keys.green % newState.keys.white === 0) {
                newState.keys.pink /= newState.keys.white;
                newState.keys.green /= newState.keys.white;
                newState.steps += 1;
                newState.path.push(`Divided pink and green keys by white (Total pink: ${newState.keys.pink}, green: ${newState.keys.green})`);
                logToOutput(`Action ${newState.steps}: Divided pink and green by white. New pink: ${newState.keys.pink}, new green: ${newState.keys.green}`);
                return newState;
            }
            return null;
        }

        async function processQueue(queue, visited, solutions) {
            const chunkSize = 100;
            let iterations = 0;

            while (queue.length > 0) {
                if (iterations >= chunkSize) {
                    iterations = 0;
                    await new Promise(resolve => setTimeout(resolve, 0));
                }

                const currentState = queue.shift();
                const keys = JSON.stringify(currentState.keys);

                if (visited.has(keys)) continue;
                visited.add(keys);

                if (isGoalCondition(currentState)) {
                    logToOutput(`Goal condition reached in ${currentState.steps} steps!`);
                    solutions.push(currentState);
                    continue;
                }

                logToOutput(`Exploring new state with ${currentState.steps} steps taken. Key counts: Cyan=${currentState.keys.cyan}, Pink=${currentState.keys.pink}, Green=${currentState.keys.green}, White=${currentState.keys.white}`);

                // Dynamically prioritize actions based on reward score
                let newStates = [
                    collectKey(currentState, 'cyan'),
                    collectKey(currentState, 'pink'),
                    collectKey(currentState, 'green'),
                    collectKey(currentState, 'white')
                ];

                const dividedState = divideKeys(currentState);
                if (dividedState) newStates.push(dividedState);

                // Sort new states based on reward score
                newStates.sort((a, b) => calculateReward(b) - calculateReward(a));
                newStates.forEach(state => queue.push(state));

                iterations++;
            }
        }

        async function startSolver() {
            document.getElementById('result').innerHTML = '';
            logToOutput("Starting solver...");

            const solutions = [];
            const queue = [initialState];
            const visited = new Set();

            await processQueue(queue, visited, solutions);

            solutions.sort((a, b) => a.steps - b.steps);

            if (solutions.length === 0) {
                logToOutput('No solutions found. Adjust conditions or check if puzzle logic is correct.');
            } else {
                solutions.forEach((solution, index) => {
                    logToOutput(`\nSolution ${index + 1} (Steps: ${solution.steps}):`);
                    logToOutput(solution.path.join(' -> '));
                });
            }
        }
    </script>
</body>
</html>
