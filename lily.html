<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>I Wanna Lockpick Puzzle Solver</title>
    <style>
        .console-output {
            width: 100%;
            height: 300px;
            overflow-y: auto;
            background-color: #333;
            color: #eee;
            font-family: monospace;
            padding: 10px;
            border: 1px solid #222;
            white-space: pre-line;
        }

        #startButton {
            margin-bottom: 10px;
        }
    </style>
</head>
<body>

<h1>I Wanna Lockpick Puzzle Solver</h1>
<button id="startButton">Start Solver</button>
<div id="log" class="console-output"></div>

<script>
// Initial puzzle data with cursed door and brown key aura requirements
const puzzleData = {
    keys: {
        green: { real: 0, imag: 0 },
        red: { real: 0, imag: 0 },
        cyan: { real: 0, imag: 0 },
        brown: { real: 0, imag: 0 }
    },
    doors: [
        { color: 'combo', type: 'normal', copies: 1, locks: [{ color: 'green', cost: { real: 5, imag: 0 } }, { color: 'red', cost: { real: 0, imag: 3 } }] },
        { color: 'cyan', type: 'normal', copies: 1, locks: [{ color: 'cyan', cost: { real: -7, imag: 0 } }] },
        { color: 'brown', type: 'cursed', copies: 1, locks: [{ color: 'brown', cost: { real: 1, imag: 0 } }] }
    ],
    keysToCollect: [
        { color: 'green', amount: { real: 5, imag: 0 } },
        { color: 'red', amount: { real: 0, imag: 3 } },
        { color: 'cyan', amount: { real: -7, imag: 0 } },
        { color: 'brown', amount: { real: -1, imag: 0 } }
    ],
    goal: { reached: false }
};

let logDiv = document.getElementById("log");

// Function to log messages with auto-scroll
function logMessage(message) {
    const messageElement = document.createElement("div");
    messageElement.textContent = message;
    logDiv.appendChild(messageElement);
    logDiv.scrollTop = logDiv.scrollHeight;
}

// Utility function to clone data without reference issues
function cloneData(data) {
    return JSON.parse(JSON.stringify(data));
}

// Collect a specific key amount and log
function collectKey(data, color, amount) {
    data.keys[color].real += amount.real;
    data.keys[color].imag += amount.imag;
    logMessage(`Collected ${amount.real !== 0 ? amount.real : ''}${amount.imag !== 0 ? (amount.real !== 0 ? ' + ' : '') + amount.imag + 'i' : ''} ${color} key(s). Total: ${data.keys[color].real} + ${data.keys[color].imag}i`);

    // Check for brown aura activation/deactivation
    if (color === 'brown') {
        if (data.keys.brown.real < 0) {
            logMessage("Negative brown aura activated! Curses can now be removed from nearby doors.");
        } else if (data.keys.brown.real > 0) {
            logMessage("Positive brown aura activated! Nearby doors are cursed.");
        }
    }
}

// Open a door if possible and log result, considering cursed status
function openDoor(data, door) {
    // Check if door is cursed and can be opened with negative brown aura
    if (door.type === 'cursed') {
        if (data.keys.brown.real < 0) {
            logMessage(`Opened cursed ${door.color} door using negative brown aura.`);
            door.copies -= 1;
            logMessage(`Remaining copies: ${door.copies}`);
            return true;
        } else {
            logMessage(`Cannot open cursed ${door.color} door without negative brown aura.`);
            return false;
        }
    }

    // Check locks for real and imaginary parts
    for (const lock of door.locks) {
        const { color, cost } = lock;
        const playerKey = data.keys[color];

        if (
            (cost.real > 0 && playerKey.real < cost.real) ||
            (cost.real < 0 && playerKey.real > cost.real) ||
            (cost.imag > 0 && playerKey.imag < cost.imag) ||
            (cost.imag < 0 && playerKey.imag > cost.imag)
        ) {
            logMessage(`Not enough ${color} keys to open ${door.color} door. Required: ${cost.real !== 0 ? cost.real : ''}${cost.imag !== 0 ? (cost.real !== 0 ? ' + ' : '') + cost.imag + 'i' : ''}, Available: ${playerKey.real} + ${playerKey.imag}i`);
            return false;
        }
    }

    // If all locks are met, open the door and deduct keys
    for (const lock of door.locks) {
        const { color, cost } = lock;
        data.keys[color].real -= cost.real;
        data.keys[color].imag -= cost.imag;
        logMessage(`Used ${cost.real !== 0 ? cost.real : ''}${cost.imag !== 0 ? (cost.real !== 0 ? ' + ' : '') + cost.imag + 'i' : ''} ${color} key(s) to open part of ${door.color} door.`);
    }

    door.copies -= 1;
    logMessage(`Opened ${door.color} door. Remaining copies: ${door.copies}`);
    return true;
}

// Check if all doors are open to reach the goal
function checkGoal(data) {
    const allDoorsOpen = data.doors.every(door => door.copies <= 0);
    if (allDoorsOpen) {
        data.goal.reached = true;
        logMessage("Goal reached! All doors are open.");
    } else {
        logMessage("Goal not yet reached.");
    }
}

// Test function to simulate puzzle solving with cursed door requirements
async function cursedDoorTest() {
    logMessage("Starting cursed door test...");

    const testData = cloneData(puzzleData);
    const steps = [];

    // Step 1: Collect green, red, and brown keys to attempt to open the doors
    collectKey(testData, 'green', { real: 5, imag: 0 });
    collectKey(testData, 'red', { real: 0, imag: 3 });
    if (openDoor(testData, testData.doors[0])) {
        steps.push("Opened combo door (green and red complex requirements).");
    }

    // Step 2: Collect cyan keys and open the cyan door with negative requirement
    collectKey(testData, 'cyan', { real: -7, imag: 0 });
    if (openDoor(testData, testData.doors[1])) {
        steps.push("Opened cyan door with negative requirement.");
    }

    // Step 3: Collect negative brown key and open the cursed door
    collectKey(testData, 'brown', { real: -1, imag: 0 });
    if (openDoor(testData, testData.doors[2])) {
        steps.push("Opened cursed brown door with negative aura.");
    }

    // Step 4: Check if goal is reached
    checkGoal(testData);

    if (testData.goal.reached) {
        logMessage("Test succeeded. Path: " + steps.join(" -> "));
    } else {
        logMessage("Test failed. Goal was not reached.");
    }
}

// Add event listener to the button to start the test
document.getElementById("startButton").addEventListener("click", cursedDoorTest);

</script>
</body>
</html>
