<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>I Wanna Lockpick Solver</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f4;
            color: #333;
            text-align: center;
            padding: 20px;
        }
        #solver-container {
            max-width: 800px;
            margin: 0 auto;
        }
        #output {
            margin-top: 20px;
            padding: 10px;
            background-color: #e9e9e9;
            border: 1px solid #ccc;
            border-radius: 5px;
            overflow-y: scroll;
            max-height: 300px;
            text-align: left;
        }
    </style>
</head>
<body>
    <div id="solver-container">
        <h1>I Wanna Lockpick Solver</h1>
        <p>Click the button below to start the brute-force solver for "I Wanna Lockpick".</p>
        <button onclick="startSolver()">Start Solver</button>

        <div id="output">
            <h2>Solver Output</h2>
            <pre id="result"></pre>
        </div>
    </div>

    <script>
        // Define initial state for the puzzle
        const initialState = {
            keys: { white: 0, cyan: 0, pink: 0, green: 0 },
            steps: 0,  // Track the number of actions (collect or door interactions)
            path: []   // Sequence of actions taken
        };

        // Define target condition for solution
        const targetKeys = { cyan: 28, pink: 7, green: 21 };  // Adjust as necessary based on puzzle goal

        // Collect a key of a specific color
        function collectKey(state, color) {
            const newState = JSON.parse(JSON.stringify(state));
            newState.keys[color]++;
            newState.steps += 1;
            newState.path.push(`Collect ${color} key`);
            console.log(`Collected ${color} key: New count = ${newState.keys[color]}`);
            return newState;
        }

        // Use a division machine to divide pink and green keys by white if possible
        function divideKeys(state) {
            const newState = JSON.parse(JSON.stringify(state));
            if (newState.keys.white > 0 && newState.keys.pink % newState.keys.white === 0 && newState.keys.green % newState.keys.white === 0) {
                newState.keys.pink /= newState.keys.white;
                newState.keys.green /= newState.keys.white;
                newState.steps += 1;
                newState.path.push(`Divide pink and green by white (${newState.keys.white})`);
                console.log(`Divided pink and green by white: pink = ${newState.keys.pink}, green = ${newState.keys.green}`);
                return newState;
            }
            return null; // Cannot divide if conditions are not met
        }

        // Check if the state meets the target conditions
        function isGoalReached(state) {
            return (
                state.keys.cyan === targetKeys.cyan &&
                state.keys.pink === targetKeys.pink &&
                state.keys.green === targetKeys.green
            );
        }

        // Brute-force solver function
        function bruteForceSolver(state) {
            const solutions = [];
            const queue = [state];
            const visited = new Set();

            while (queue.length > 0) {
                const currentState = queue.shift();
                const keys = JSON.stringify(currentState.keys);

                // Skip if this state has been visited
                if (visited.has(keys)) continue;
                visited.add(keys);

                // Check if goal is reached
                if (isGoalReached(currentState)) {
                    solutions.push(currentState);
                    continue;
                }

                // Generate new states for actions: collect cyan key or use division machine
                queue.push(collectKey(currentState, 'cyan'));

                const dividedState = divideKeys(currentState);
                if (dividedState) queue.push(dividedState);
            }

            return solutions;
        }

        // Start solver and display results
        function startSolver() {
            console.clear();
            const solutions = bruteForceSolver(initialState);
            const resultElement = document.getElementById('result');
            solutions.sort((a, b) => a.steps - b.steps);

            if (solutions.length === 0) {
                resultElement.innerHTML = 'No solutions found. Please check target key counts and ensure puzzle logic is correct.';
            } else {
                resultElement.innerHTML = '';
                solutions.forEach((solution, index) => {
                    resultElement.innerHTML += `Solution ${index + 1} (Steps: ${solution.steps}): ${solution.path.join(' -> ')}\n`;
                });
            }
        }
    </script>
</body>
</html>
